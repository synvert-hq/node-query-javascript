<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NodeQuery.html">NodeQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeQuery.html#.configure">configure</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeQuery.html#.getAdapter">getAdapter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeQuery.html#matchNode">matchNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeQuery.html#queryNodes">queryNodes</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><p><a href="https://badge.fury.io/js/@xinminlabs%2Fnode-query"><img src="https://badge.fury.io/js/@xinminlabs%2Fnode-query.svg" alt="npm version"></a>
<a href="https://github.com/xinminlabs/node-query-javascript/actions/workflows/main.yml"><img src="https://github.com/xinminlabs/node-query-javascript/actions/workflows/main.yml/badge.svg" alt="CI"></a></p>
<h1>NodeQuery</h1>
<p>NodeQuery defines a NQL (node query language) and node rules to query AST nodes.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#nodequery">NodeQuery</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#node-query-language">Node Query Language</a>
<ul>
<li><a href="#nql-matches-node-type">nql matches node type</a></li>
<li><a href="#nql-matches-attribute">nql matches attribute</a></li>
<li><a href="#nql-matches-nested-attribute">nql matches nested attribute</a></li>
<li><a href="#nql-matches-evaluated-value">nql matches evaluated value</a></li>
<li><a href="#nql-matches-nested-selector">nql matches nested selector</a></li>
<li><a href="#nql-matches-property">nql matches property</a></li>
<li><a href="#nql-matches-operators">nql matches operators</a></li>
<li><a href="#nql-matches-array-node-attribute">nql matches array node attribute</a></li>
<li><a href="#nql-matches--in-attribute-key">nql matches * in attribute key</a></li>
<li><a href="#nql-matches-multiple-selectors">nql matches multiple selectors</a>
<ul>
<li><a href="#descendant-combinator">Descendant combinator</a></li>
<li><a href="#child-combinator">Child combinator</a></li>
<li><a href="#adjacent-sibling-combinator">Adjacent sibling combinator</a></li>
<li><a href="#general-sibling-combinator">General sibling combinator</a></li>
</ul>
</li>
<li><a href="#nql-matches-goto-scope">nql matches goto scope</a></li>
<li><a href="#nql-matches-has-and-not_has-pseudo-selector">nql matches :has and :not_has pseudo selector</a></li>
<li><a href="#nql-matches-first-child-and-last-child-selector">nql matches :first-child and :last-child selector</a></li>
<li><a href="#nql-matches-multiple-expressions">nql matches multiple expressions</a></li>
</ul>
</li>
<li><a href="#node-rules">Node Rules</a>
<ul>
<li><a href="#rules-matches-node-type">rules matches node type</a></li>
<li><a href="#rules-matches-attribute">rules matches attribute</a></li>
<li><a href="#rules-matches-nested-attribute">rules matches nested attribute</a></li>
<li><a href="#rules-matches-evaluated-value">rules matches evaluated value</a></li>
<li><a href="#rules-matches-nested-selector">rules matches nested selector</a></li>
<li><a href="#rules-matches-property">rules matches property</a></li>
<li><a href="#rules-matches-operators">rules matches operators</a></li>
<li><a href="#rules-matches-array-node-attribute">rules matches array node attribute</a></li>
</ul>
</li>
<li><a href="#write-adapter">Write Adapter</a></li>
<li><a href="#contributing-guide">Contributing Guide</a></li>
</ul>
</li>
</ul>
<h2>Installation</h2>
<p>Install NodeQuery using npm:</p>
<pre class="prettyprint source"><code>npm install --save @xinminlabs/node-query
</code></pre>
<p>Or yarn:</p>
<pre class="prettyprint source"><code>yarn add @xinminlabs/node-query
</code></pre>
<h2>Usage</h2>
<p>It provides two apis: <code>queryNodes</code> and <code>matchNode</code></p>
<pre class="prettyprint source lang-typescript"><code>const nodeQuery = new NodeQuery&lt;Node>(nqlOrRules: string | object) // Initialize NodeQuery
nodeQuery.queryNodes(node: Node, includingSelf = true): Node[] // Get the matching nodes.
nodeQuery.matchNode(node: Node): boolean // Check if the node matches nql or rules.
</code></pre>
<p>Here is an example for typescript ast node.</p>
<pre class="prettyprint source lang-typescript"><code>import ts, { Node } from 'typescript';
import NodeQuery from '@xinminlabs/node-query';

const source = `
  interface User {
    name: string;
    id: number;
  }

  class UserAccount {
    name: string;
    id: number;

    constructor(name: string, id: number) {
      this.name = name;
      this.id = id;
    }
  }

  const user: User = new UserAccount(&quot;Murphy&quot;, 1);
`
const node = ts.createSourceFile('code.ts', source, ts.ScriptTarget.Latest, true)

// It will get the two nodes of property declaration in the class declaration.
new NodeQuery&lt;Node>('.ClassDeclaration .PropertyDeclaration').queryNodes(node)
new NodeQuery&lt;Node>({ nodeType: &quot;PropertyDeclaration&quot; }).queryNodes(node)
</code></pre>
<h2>Node Query Language</h2>
<h3>nql matches node type</h3>
<pre class="prettyprint source"><code>.ClassDeclaration
</code></pre>
<p>It matches ClassDeclaration node</p>
<h3>nql matches attribute</h3>
<pre class="prettyprint source"><code>.NewExpression[expression=UserAccount]
</code></pre>
<p>It matches NewExpression node whose expression value is UserAccount</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.0=&quot;Murphy&quot;][arguments.-1=1]
</code></pre>
<p>It matches NewExpression node whose first argument is &quot;Murphy&quot; and second argument is 1</p>
<h3>nql matches nested attribute</h3>
<pre class="prettyprint source"><code>.NewExpression[expression.escapedText=UserAccount]
</code></pre>
<p>It matches NewExpression node whose escapedText of expression is UserAccount</p>
<h3>nql matches evaluated value</h3>
<pre class="prettyprint source"><code>.PropertyAssignment[name=&quot;{{initializer}}&quot;]
</code></pre>
<p>It matches PropertyAssignement node whose node value of name matches node value of intiailizer</p>
<h3>nql matches nested selector</h3>
<pre class="prettyprint source"><code>.VariableDeclaration[initializer=.NewExpression[expression=UserAccount]]
</code></pre>
<p>It matches VariableDelclaration node whose initializer is a NewExpression node whose expression is UserAccount</p>
<h3>nql matches property</h3>
<pre class="prettyprint source"><code>.NewExpression[arguments.length=2]
</code></pre>
<p>It matches NewExpression node whose arguments length is 2</p>
<h3>nql matches operators</h3>
<pre class="prettyprint source"><code>.NewExpression[expression=UserAccount]
</code></pre>
<p>Value of expression is equal to UserAccount</p>
<pre class="prettyprint source"><code>.NewExpression[expression^=User]
</code></pre>
<p>Value of expression starts with User</p>
<pre class="prettyprint source"><code>.NewExpression[expression$=Account]
</code></pre>
<p>Value of expression ends with Account</p>
<pre class="prettyprint source"><code>.NewExpression[expression*=Acc]
</code></pre>
<p>Value of expression contains Account</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.length!=0]
</code></pre>
<p>Length of arguments is not equal to 0</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.length>=2]
</code></pre>
<p>Length of arguments is greater than or equal to 2</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.length>1]
</code></pre>
<p>Length of arguments is greater than 1</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.length&lt;=2]
</code></pre>
<p>Length of arguments is less than or equal to 2</p>
<pre class="prettyprint source"><code>.NewExpression[arguments.length&lt;3]
</code></pre>
<p>Length of arguments is less than 3</p>
<pre class="prettyprint source"><code>.NewExpression[arguments INCLUDES &quot;Murphy&quot;]
</code></pre>
<p>It matches NewExpressioin node one of whose arguments is &quot;Murphy&quot;</p>
<pre class="prettyprint source"><code>.NewExpression[arguments NOT INCLUDES &quot;Murphy&quot;]
</code></pre>
<p>It matches NewExpressioin node none of whose arguments is &quot;Murphy&quot;</p>
<pre class="prettyprint source"><code>.ClassDeclaration[name IN (User Account UserAccount)]
</code></pre>
<p>Value of name matches any of User, Account and UserAccount</p>
<pre class="prettyprint source"><code>.ClassDeclaration[name NOT IN (User Account)]
</code></pre>
<p>Value of name does not match all of User and Account</p>
<pre class="prettyprint source"><code>.ClassDeclaration[name=~/^User/]
</code></pre>
<p>Value of name starts with User</p>
<pre class="prettyprint source"><code>.ClassDeclaration[name!=~/^User/]
</code></pre>
<p>Value of name does not start with User</p>
<pre class="prettyprint source"><code>.ClassDeclaration[name IN (/User/ /Account/)]
</code></pre>
<p>Value of name matches any of /User/ and /Account/</p>
<h3>nql matches array node attribute</h3>
<pre class="prettyprint source"><code>.NewExpression[arguments=(&quot;Murphy&quot; 1)]
</code></pre>
<p>It matches NewExpressioin node whose arguments are [&quot;Murphy&quot;, 1]</p>
<h3>nql matches * in attribute key</h3>
<pre class="prettyprint source"><code>.Constructor[parameters.*.name IN (name id)]
</code></pre>
<p>It matches Constructor whose parameters' names are all in [name id]</p>
<h3>nql matches multiple selectors</h3>
<h4>Descendant combinator</h4>
<pre class="prettyprint source"><code>.ClassDeclaration .Constructor
</code></pre>
<p>It matches Constructor node whose ancestor matches the ClassDeclaration node</p>
<h4>Child combinator</h4>
<pre class="prettyprint source"><code>.ClassDeclaration > .PropertyDeclaration
</code></pre>
<p>It matches PropertyDeclaration node whose parent matches the ClassDeclartion node</p>
<h4>Adjacent sibling combinator</h4>
<pre class="prettyprint source"><code>.PropertyDeclaration[name=name] + .PropertyDeclaration
</code></pre>
<p>It matches PropertyDeclaration node only if it immediately follows the PropertyDeclaration whose name is name</p>
<h4>General sibling combinator</h4>
<pre class="prettyprint source"><code>.PropertyDeclaration[name=name] ~ .PropertyDeclaration
</code></pre>
<p>It matches PropertyDeclaration node only if it follows the PropertyDeclaration whose name is name</p>
<h3>nql matches goto scope</h3>
<pre class="prettyprint source"><code>.ClassDeclaration members .PropertyDeclaration
</code></pre>
<p>It matches PropertyDeclaration node who is in the members of ClassDeclaration node</p>
<h3>nql matches :has and :not_has pseudo selector</h3>
<pre class="prettyprint source"><code>.ClassDeclaration:has(.Constructor)
</code></pre>
<p>It matches ClassDeclaration node if it has a Constructor node</p>
<pre class="prettyprint source"><code>.ClassDeclaration:not_has(.Constructor)
</code></pre>
<p>It matches ClassDeclaration node if it does not have a Constructor node</p>
<h3>nql matches :first-child and :last-child selector</h3>
<pre class="prettyprint source"><code>.MethodDefinition:first-child
</code></pre>
<p>It matches the first MethodDefinition node</p>
<pre class="prettyprint source"><code>.MethodDefinition:last-child
</code></pre>
<p>It matches the last MethodDefinition node</p>
<h3>nql matches multiple expressions</h3>
<pre class="prettyprint source"><code>.JSXOpeningElement[name=Fragment], .JSXClosingElement[name=Fragment]
</code></pre>
<p>It matches JSXOpeningElement node whose name is Fragment or JSXClosingElement node whose name is Fragment</p>
<h2>Node Rules</h2>
<h3>rules matches node type</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot; }
</code></pre>
<p>It matches ClassDeclaration node</p>
<h3>rules matches attribute</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, expression: &quot;UserAccount&quot; }
</code></pre>
<p>It matches NewExpression node whose expression value is UserAccount</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { 0: &quot;Murphy&quot;, 1: 1 } }
</code></pre>
<p>It matches NewExpression node whose first argument is &quot;Murphy&quot; and second argument is 1</p>
<h3>rules matches nested attribute</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, expression: { escapedText: &quot;UserAccount&quot; } }
</code></pre>
<p>It matches NewExpression node whose escapedText of expression is UserAccount</p>
<h3>rules matches evaluated value</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;PropertyAssignment&quot;, name: &quot;{{initializer}}&quot; }
</code></pre>
<p>It matches PropertyAssignement node whose node value of name matches node value of intiailizer</p>
<h3>rules matches nested selector</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;VariableDeclaration&quot;, initializer: { nodeType: &quot;NewExpression&quot;, expression: &quot;UserAccount&quot; } }
</code></pre>
<p>It matches VariableDelclaration node whose initializer is a NewExpression node whose expression is UserAccount</p>
<h3>rules matches property</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: 2 } }
</code></pre>
<p>It matches NewExpression node whose arguments length is 2</p>
<h3>rules matches operators</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, expression: &quot;UserAccount&quot; }
</code></pre>
<p>Value of expression is equal to UserAccount</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: { not: 0 } } }
</code></pre>
<p>Length of arguments is not equal to 0</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: { gte: 2 } } }
</code></pre>
<p>Length of arguments is greater than or equal to 2</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: { gt: 1 } } }
</code></pre>
<p>Length of arguments is greater than 1</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: { lte: 2 } } }
</code></pre>
<p>Length of arguments is less than or equal to 2</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { length: { lt: 3 } } }
</code></pre>
<p>Length of arguments is less than 3</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { includes: &quot;Murphy&quot; } }
</code></pre>
<p>It matches NewExpressioin node one of whose arguments is &quot;Murphy&quot;</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: { notIncludes: &quot;Murphy&quot; } }
</code></pre>
<p>It matches NewExpressioin node none of whose arguments is &quot;Murphy&quot;</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot;, name: { in: [User Account UserAccount] } }
</code></pre>
<p>Value of name matches any of User, Account and UserAccount</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot;, name: { notIn: [User Account] } }
</code></pre>
<p>Value of name does not match all of User and Account</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot;, name: /^User/ }
</code></pre>
<p>Value of name starts with User</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot;, name: { not: /^User/ } }
</code></pre>
<p>Value of name does not start with User</p>
<pre class="prettyprint source"><code>{ nodeType: &quot;ClassDeclaration&quot;, name: { in: [/User/, /Account/] } }
</code></pre>
<p>Value of name matches any of /User/ and /Account/</p>
<h3>rules matches array node attribute</h3>
<pre class="prettyprint source"><code>{ nodeType: &quot;NewExpression&quot;, arguments: [&quot;Murphy&quot;, 1] }
</code></pre>
<p>It matches NewExpressioin node whose arguments are [&quot;Murphy&quot;, 1]</p>
<h2>Write Adapter</h2>
<p>Different parsers, like typescript, espree, will generate different AST nodes, to make NodeQuery work for them all,
we define an <a href="https://github.com/xinminlabs/node-query-javascript/blob/main/src/adapter.ts">Adapter</a> interface,
if you implement the Adapter interface, you can set it as NodeQuery's adapter.</p>
<p>It provides 3 adapters</p>
<ol>
<li><code>TypescriptAdapter</code></li>
<li><code>EspreeAdapter</code></li>
<li><code>GonzalesPeAdapter</code></li>
</ol>
<pre class="prettyprint source lang-typescript"><code>NodeQuery.configure({ adapter: new EspreeAdapter() }) // default is TypescriptAdapter
</code></pre>
<h2>Contributing Guide</h2>
<ol>
<li>
<p>Fork and clone the repo.</p>
</li>
<li>
<p>Run <code>npm install</code> to install dependencies.</p>
</li>
<li>
<p>Run <code>npm run generate</code> or <code>npm run watch:generate</code> to generate <code>src/parser.js</code>.</p>
</li>
<li>
<p>Run <code>npm run test</code> or <code>npm run watch:test</code> to run tests.</p>
</li>
<li>
<p>Make some changes and make tests all passed.</p>
</li>
<li>
<p>Push the changes to the repo.</p>
</li>
</ol></article>
    </section>






</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Sun May 28 2023 04:58:11 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>